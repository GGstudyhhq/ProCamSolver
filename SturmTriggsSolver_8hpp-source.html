<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>ProCamSolver: SturmTriggsSolver.hpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<h1>SturmTriggsSolver.hpp</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00002"></a>00002 <span class="comment">//</span>
<a name="l00003"></a>00003 <span class="comment">// Copyright (c) 2012 Daniel Tang.</span>
<a name="l00004"></a>00004 <span class="comment">//</span>
<a name="l00005"></a>00005 <span class="comment">//  Licensed under the Apache License, Version 2.0 (the "License");</span>
<a name="l00006"></a>00006 <span class="comment">//  you may not use this file except in compliance with the License.</span>
<a name="l00007"></a>00007 <span class="comment">//  You may obtain a copy of the License at</span>
<a name="l00008"></a>00008 <span class="comment">//</span>
<a name="l00009"></a>00009 <span class="comment">//       http://www.apache.org/licenses/LICENSE-2.0</span>
<a name="l00010"></a>00010 <span class="comment">//</span>
<a name="l00011"></a>00011 <span class="comment">//   Unless required by applicable law or agreed to in writing,</span>
<a name="l00012"></a>00012 <span class="comment">//   software distributed under the License is distributed on an "AS</span>
<a name="l00013"></a>00013 <span class="comment">//   IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either</span>
<a name="l00014"></a>00014 <span class="comment">//   express or implied.  See the License for the specific language</span>
<a name="l00015"></a>00015 <span class="comment">//   governing permissions and limitations under the License.</span>
<a name="l00016"></a>00016 <span class="comment">//</span>
<a name="l00018"></a>00018 <span class="comment"></span>
<a name="l00019"></a>00019 <span class="preprocessor">#include "AdjacencyMatrix.h"</span>
<a name="l00020"></a>00020 <span class="preprocessor">#include "FundamentalMatrix.h"</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include "MotionMatrix.h"</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include "MeasurementMatrix.h"</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include "ShapeMatrix.h"</span>
<a name="l00024"></a>00024 
<a name="l00026"></a>00026 <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> M&gt;
<a name="l00027"></a>00027 <a class="code" href="classSturmTriggsSolver.html">SturmTriggsSolver&lt;M&gt;::SturmTriggsSolver</a>(<a class="code" href="classMotionMatrix.html">MotionMatrix&lt;M&gt;</a> &amp;P,
<a name="l00028"></a>00028                                         <a class="code" href="classShapeMatrix.html">ShapeMatrix</a> &amp;S) :
<a name="l00029"></a>00029   motion(P),
<a name="l00030"></a>00030   shape(S)
<a name="l00031"></a>00031 {
<a name="l00032"></a>00032 }
<a name="l00033"></a>00033 
<a name="l00034"></a>00034 
<a name="l00040"></a>00040 <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> M&gt;
<a name="l00041"></a><a class="code" href="classSturmTriggsSolver.html#7d1e22875ff501d95284b0c06d35db11">00041</a> <span class="keywordtype">void</span> <a class="code" href="classSturmTriggsSolver.html#7d1e22875ff501d95284b0c06d35db11">SturmTriggsSolver&lt;M&gt;::solve</a>(<span class="keyword">const</span> <a class="code" href="classMeasurementMatrix.html">MeasurementMatrix&lt;M&gt;</a> &amp;E) {
<a name="l00042"></a>00042   Eigen::JacobiSVD&lt;typename MeasurementMatrix&lt;M&gt;::Base&gt;         svd;
<a name="l00043"></a>00043   <a class="code" href="classImageTransform.html">ImageTransform&lt;M&gt;</a>                             denormalisation;
<a name="l00044"></a>00044 
<a name="l00045"></a>00045   <a class="code" href="classSturmTriggsSolver.html#1e4d064b50910113954e779a2bb1ea5f">set_measurement_matrix</a>(E);
<a name="l00046"></a>00046   measurement.normalise(denormalisation);
<a name="l00047"></a>00047 
<a name="l00048"></a>00048   std::cout &lt;&lt; <span class="stringliteral">"Normalised measurement norm ="</span> &lt;&lt; std::endl;
<a name="l00049"></a>00049   std::cout &lt;&lt; measurement.rowwise().norm()/sqrt(measurement.cols()) &lt;&lt; std::endl;
<a name="l00050"></a>00050 
<a name="l00051"></a>00051   <a class="code" href="classSturmTriggsSolver.html#bd1678a4d28abf421a146291d2e1421b">approx_scale</a>();
<a name="l00052"></a>00052   <a class="code" href="classSturmTriggsSolver.html#28757549771eb8cf6bd611293a9748b2">factorise_with_occlusions</a>(motion, shape);
<a name="l00053"></a>00053 
<a name="l00054"></a>00054   std::cout &lt;&lt; <span class="stringliteral">"First guess at motion matrix = "</span> &lt;&lt; std::endl;
<a name="l00055"></a>00055   std::cout &lt;&lt; motion &lt;&lt; std::endl;
<a name="l00056"></a>00056   std::cout &lt;&lt; <span class="stringliteral">"shapenorm = "</span> &lt;&lt; std::endl;
<a name="l00057"></a>00057   std::cout &lt;&lt; shape.rowwise().norm()/sqrt(shape.cols()) &lt;&lt; std::endl;
<a name="l00058"></a>00058 
<a name="l00059"></a>00059   Eigen::VectorXd err;
<a name="l00060"></a>00060   motion.<a class="code" href="classMotionMatrix.html#92a5815802fd8c0b9d7bb4a9bce7774c">reprojection_err</a>(measurement, err);
<a name="l00061"></a>00061   std::cout &lt;&lt; <span class="stringliteral">"Normalised reprojection err = "</span> &lt;&lt; std::endl;
<a name="l00062"></a>00062   std::cout &lt;&lt; err.norm()/sqrt(err.rows())&lt;&lt;std::endl;
<a name="l00063"></a>00063 
<a name="l00064"></a>00064   measurement.scale_and_fill(motion, shape);
<a name="l00065"></a>00065   svd.compute(measurement, Eigen::ComputeThinV | Eigen::ComputeThinU);
<a name="l00066"></a>00066   motion = svd.matrixU().leftCols(4);
<a name="l00067"></a>00067   <span class="comment">// motion *= svd.singularValues().topRows(4).asDiagonal();</span>
<a name="l00068"></a>00068 
<a name="l00069"></a>00069   std::cout &lt;&lt; <span class="stringliteral">"Sturm-Triggs singular values are:"</span> &lt;&lt; std::endl;
<a name="l00070"></a>00070   std::cout &lt;&lt; svd.singularValues() &lt;&lt; std::endl;
<a name="l00071"></a>00071 
<a name="l00072"></a>00072   denormalisation.<a class="code" href="classImageTransform.html#a846855658e2aae72b7514d0849c0461">apply_to</a>(motion);
<a name="l00073"></a>00073 }
<a name="l00074"></a>00074 
<a name="l00075"></a>00075 
<a name="l00082"></a>00082 <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> M&gt;
<a name="l00083"></a><a class="code" href="classSturmTriggsSolver.html#28757549771eb8cf6bd611293a9748b2">00083</a> <span class="keywordtype">void</span> <a class="code" href="classSturmTriggsSolver.html#28757549771eb8cf6bd611293a9748b2">SturmTriggsSolver&lt;M&gt;::factorise_with_occlusions</a>(<a class="code" href="classMotionMatrix.html">MotionMatrix&lt;M&gt;</a> &amp;motion, 
<a name="l00084"></a>00084                                                      <a class="code" href="classShapeMatrix.html">ShapeMatrix</a> &amp;shape) {
<a name="l00085"></a>00085   <a class="code" href="classMeasurementMatrix.html">MeasurementMatrix&lt;M&gt;</a>  notMotion;      <span class="comment">// nullspace of this is motion matrix</span>
<a name="l00086"></a>00086   <a class="code" href="classMeasurementMatrix.html">MeasurementMatrix&lt;M&gt;</a>  subspace;       <span class="comment">// nullspace of this is a constraint</span>
<a name="l00087"></a>00087                                         <span class="comment">// on motionMatrix</span>
<a name="l00088"></a>00088   Eigen::JacobiSVD&lt;typename MeasurementMatrix&lt;M&gt;::Base&gt; subspaceSvd;
<a name="l00089"></a>00089   std::vector&lt;int&gt;      permutation(measurement.cols());
<a name="l00090"></a>00090   <span class="keywordtype">int</span>                   i, j, j0;
<a name="l00091"></a>00091   <span class="keywordtype">int</span>                   c;
<a name="l00092"></a>00092   <span class="keywordtype">int</span>                   srank;
<a name="l00093"></a>00093   <span class="keywordtype">int</span>                   nmRank;
<a name="l00094"></a>00094   <span class="keyword">const</span> <span class="keywordtype">double</span>  singular_cutoff=0.01;   <span class="comment">// cutoff value for rank calculation</span>
<a name="l00095"></a>00095 
<a name="l00096"></a>00096   <span class="comment">// --- calculate the best permutation of</span>
<a name="l00097"></a>00097   <span class="comment">// --- columns of the measurement matrix</span>
<a name="l00098"></a>00098   <span class="comment">// -------------------------------------</span>
<a name="l00099"></a>00099   <span class="keywordflow">for</span>(i=0; i&lt;permutation.size(); ++i) {
<a name="l00100"></a>00100     permutation[i] = i;
<a name="l00101"></a>00101   }
<a name="l00102"></a>00102   std::cout &lt;&lt; <span class="stringliteral">"Permuting..."</span> &lt;&lt; std::endl;
<a name="l00103"></a>00103   <a class="code" href="classSturmTriggsSolver.html#1d01bcc1c1ef42701620a90e4b3a3290">random_permute</a>(permutation);
<a name="l00104"></a>00104   std::cout &lt;&lt; <span class="stringliteral">"Sorting..."</span> &lt;&lt; std::endl;
<a name="l00105"></a>00105   std::sort(permutation.begin(), permutation.end(), colCompare(measurement));
<a name="l00106"></a>00106   std::cout &lt;&lt; <span class="stringliteral">"Forming subspaces..."</span> &lt;&lt; std::endl;
<a name="l00107"></a>00107 
<a name="l00108"></a>00108   <span class="comment">// --- calculate motion matrix</span>
<a name="l00109"></a>00109   <span class="comment">// --- from subspace constraints</span>
<a name="l00110"></a>00110   <span class="comment">// -----------------------------</span>
<a name="l00111"></a>00111   c = 0;        <span class="comment">// current position in permutation</span>
<a name="l00112"></a>00112   nmRank = 0;
<a name="l00113"></a>00113   <span class="keywordflow">while</span>(c &lt; permutation.size()-4) {
<a name="l00114"></a>00114 
<a name="l00115"></a>00115     form_subspace(permutation.begin() + c, subspace);
<a name="l00116"></a>00116 
<a name="l00117"></a>00117     <span class="keywordflow">if</span>(subspace.cols() &lt; 3*M-1) {
<a name="l00118"></a>00118       subspaceSvd.compute(subspace, Eigen::ComputeFullU);
<a name="l00119"></a>00119       <span class="keywordflow">if</span>(subspaceSvd.singularValues()(subspace.cols()-1)/subspaceSvd.singularValues()(0) &gt; singular_cutoff) {
<a name="l00120"></a>00120         <span class="comment">// -- found full rank subspace</span>
<a name="l00121"></a>00121         notMotion.<a class="code" href="classMeasurementMatrix.html#05d194eb20237c7c874213c74819754b">new_columns</a>(3*M-subspace.cols());
<a name="l00122"></a>00122         notMotion.rightCols(3*M-subspace.cols()) = 
<a name="l00123"></a>00123           subspaceSvd.matrixU().rightCols(3*M-subspace.cols());
<a name="l00124"></a>00124 
<a name="l00125"></a>00125         <span class="comment">//      std::cout &lt;&lt; "Subspace singular values = " &lt;&lt; std::endl </span>
<a name="l00126"></a>00126         <span class="comment">//  &lt;&lt; subspaceSvd.singularValues() &lt;&lt; std::endl;</span>
<a name="l00127"></a>00127         <span class="comment">//std::cout &lt;&lt; "NotMotion singular values = " &lt;&lt; std::endl </span>
<a name="l00128"></a>00128         <span class="comment">//&lt;&lt; notMotion.jacobiSvd().singularValues() &lt;&lt; std::endl;</span>
<a name="l00129"></a>00129 
<a name="l00130"></a>00130         <span class="comment">//      c += 4;</span>
<a name="l00131"></a>00131         c += 1;
<a name="l00132"></a>00132       } <span class="keywordflow">else</span> {
<a name="l00133"></a>00133         <span class="comment">//      c += 2;</span>
<a name="l00134"></a>00134         c += 1;
<a name="l00135"></a>00135       }
<a name="l00136"></a>00136     } <span class="keywordflow">else</span> {
<a name="l00137"></a>00137       <span class="comment">// c += 2;</span>
<a name="l00138"></a>00138       c += 1;
<a name="l00139"></a>00139     }
<a name="l00140"></a>00140   }
<a name="l00141"></a>00141 
<a name="l00142"></a>00142   <span class="keywordflow">if</span>(notMotion.cols() &lt; 3*M-4) {
<a name="l00143"></a>00143     <span class="keywordflow">throw</span>(<span class="stringliteral">"Couldn't gather enough information to fill in the Measurement matrix."</span>);
<a name="l00144"></a>00144   }
<a name="l00145"></a>00145 
<a name="l00146"></a>00146   subspaceSvd.compute(notMotion, Eigen::ComputeFullU);
<a name="l00147"></a>00147   <span class="keywordflow">if</span>(subspaceSvd.singularValues()(3*M-5) &lt; singular_cutoff) {
<a name="l00148"></a>00148     <span class="keywordflow">throw</span>(<span class="stringliteral">"Too many occlusions to fill in the Measurement matrix."</span>);
<a name="l00149"></a>00149   }
<a name="l00150"></a>00150 
<a name="l00151"></a>00151   std::cout &lt;&lt; <span class="stringliteral">"NotMotion singular values = "</span> &lt;&lt; std::endl 
<a name="l00152"></a>00152             &lt;&lt; subspaceSvd.singularValues() &lt;&lt; std::endl;
<a name="l00153"></a>00153 
<a name="l00154"></a>00154 
<a name="l00155"></a>00155   <span class="comment">// --- motion is approximate nullspace of the complement</span>
<a name="l00156"></a>00156   motion = subspaceSvd.matrixU().rightCols(4);
<a name="l00157"></a>00157 
<a name="l00158"></a>00158   shape.<a class="code" href="classShapeMatrix.html#5f265d5a7cefa476b808613e605a8e86">solve</a>(measurement, motion);
<a name="l00159"></a>00159 }
<a name="l00160"></a>00160 
<a name="l00161"></a>00161 
<a name="l00167"></a>00167 <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> M&gt;
<a name="l00168"></a>00168 <span class="keywordtype">void</span> <a class="code" href="classSturmTriggsSolver.html#f9c8874c96e7189a154cef6bae5c60bc">SturmTriggsSolver&lt;M&gt;::</a>
<a name="l00169"></a><a class="code" href="classSturmTriggsSolver.html#f9c8874c96e7189a154cef6bae5c60bc">00169</a> <a class="code" href="classSturmTriggsSolver.html#f9c8874c96e7189a154cef6bae5c60bc">create_connectivity_graph</a>(Eigen::Matrix&lt;double,M,M&gt; &amp;G) {
<a name="l00170"></a>00170   <span class="keywordtype">int</span>           v1,v2,j;
<a name="l00171"></a>00171   <span class="keywordtype">int</span>           connections;
<a name="l00172"></a>00172   <span class="keyword">const</span> <span class="keywordtype">double</span>  k = -0.2;
<a name="l00173"></a>00173 
<a name="l00174"></a>00174   G.fill(1e6);
<a name="l00175"></a>00175   <span class="keywordflow">for</span>(v1 = 0; v1&lt;M; ++v1) {
<a name="l00176"></a>00176     <span class="keywordflow">for</span>(v2 = v1+1; v2&lt;M; ++v2) {
<a name="l00177"></a>00177       j = 0;
<a name="l00178"></a>00178       connections = 0;
<a name="l00179"></a>00179       <span class="keywordflow">while</span>(j &lt; measurement.cols() &amp;&amp; connections &lt; 50) {
<a name="l00180"></a>00180         <span class="keywordflow">if</span>(measurement.pixel(v1,j)(2) &gt; 0 &amp;&amp; measurement.pixel(v2,j)(2) &gt; 0) {
<a name="l00181"></a>00181           ++connections;
<a name="l00182"></a>00182         }
<a name="l00183"></a>00183         ++j;
<a name="l00184"></a>00184       }
<a name="l00185"></a>00185       <span class="keywordflow">if</span>(connections &gt; 7) {
<a name="l00186"></a>00186         G(v1,v2) = G(v2,v1) = exp(k*connections);
<a name="l00187"></a>00187       }
<a name="l00188"></a>00188     }
<a name="l00189"></a>00189   }
<a name="l00190"></a>00190 }
<a name="l00191"></a>00191 
<a name="l00192"></a>00192 
<a name="l00199"></a>00199 <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> M&gt;
<a name="l00200"></a><a class="code" href="classSturmTriggsSolver.html#bd1678a4d28abf421a146291d2e1421b">00200</a> <span class="keywordtype">void</span> <a class="code" href="classSturmTriggsSolver.html#bd1678a4d28abf421a146291d2e1421b">SturmTriggsSolver&lt;M&gt;::approx_scale</a>() {
<a name="l00201"></a>00201   Eigen::Vector3d               cross_prod, pix;    
<a name="l00202"></a>00202   <span class="keywordtype">int</span>                           v,pt,parent,i;
<a name="l00203"></a>00203   <span class="keywordtype">double</span>                        scale;
<a name="l00204"></a>00204   <a class="code" href="classFundamentalMatrix.html">FundamentalMatrix</a>             F[M];
<a name="l00205"></a>00205 
<a name="l00206"></a>00206   <span class="comment">// --- create fundamental matrices for</span>
<a name="l00207"></a>00207   <span class="comment">// --- each edge in the spanning tree </span>
<a name="l00208"></a>00208   <span class="comment">// ----------------------------------</span>
<a name="l00209"></a>00209   <span class="keywordflow">for</span>(v = 0; v&lt;M; ++v) {
<a name="l00210"></a>00210     <span class="keywordflow">if</span>(v != tree_traversal(0)) {
<a name="l00211"></a>00211       F[v].<a class="code" href="classFundamentalMatrix.html#c30c8d27c952ca0c29cd96fe813a0154">eight_point_algorithm</a>(measurement.view(v),
<a name="l00212"></a>00212                                  measurement.view(spanning_tree(v)));
<a name="l00213"></a>00213       F[v].<a class="code" href="classFundamentalMatrix.html#1ab990e56942d0ae5f7fa27ad2d92cc2">remove_outliers</a>(measurement.view(v),
<a name="l00214"></a>00214                            measurement.view(spanning_tree(v)), 3.0);
<a name="l00215"></a>00215     }
<a name="l00216"></a>00216   }
<a name="l00217"></a>00217 
<a name="l00218"></a>00218   <span class="comment">// --- Do scaling over tree</span>
<a name="l00219"></a>00219   <span class="comment">// ------------------------</span>
<a name="l00220"></a>00220   <span class="keywordflow">for</span>(v = 1; v&lt;M; ++v) {
<a name="l00221"></a>00221     i = tree_traversal(v);
<a name="l00222"></a>00222     parent = spanning_tree(i);
<a name="l00223"></a>00223     <span class="comment">// --- scale between i and parent of i</span>
<a name="l00224"></a>00224     <span class="keywordflow">for</span>(pt = 0; pt&lt;measurement.cols(); ++pt) {
<a name="l00225"></a>00225       <span class="keywordflow">if</span>(!measurement.pixel_is_occluded(i,pt)) {
<a name="l00226"></a>00226         <span class="keywordflow">if</span>(!measurement.pixel_is_occluded(parent,pt)) {
<a name="l00227"></a>00227           pix        = measurement.pixel(i,pt);
<a name="l00228"></a>00228           cross_prod = F[i].<a class="code" href="classFundamentalMatrix.html#330b14822446eea834780e92c05e4b9f">e_ij</a>().cross(pix);
<a name="l00229"></a>00229           scale      = 
<a name="l00230"></a>00230             cross_prod.dot(F[i]*measurement.pixel(parent,pt))/
<a name="l00231"></a>00231             cross_prod.dot(cross_prod);
<a name="l00232"></a>00232           measurement.pixel(i,pt) *= scale;
<a name="l00233"></a>00233         } <span class="keywordflow">else</span> {
<a name="l00234"></a>00234           <span class="comment">// --- parent occluded so scale to 1.0</span>
<a name="l00235"></a>00235           <span class="comment">// --- for later separation</span>
<a name="l00236"></a>00236           measurement.pixel(i,pt) /= measurement.pixel(i,pt)(2);
<a name="l00237"></a>00237         }
<a name="l00238"></a>00238       }
<a name="l00239"></a>00239     }
<a name="l00240"></a>00240   }
<a name="l00241"></a>00241 }
<a name="l00242"></a>00242 
<a name="l00243"></a>00243 
<a name="l00267"></a>00267 <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> M&gt;
<a name="l00268"></a>00268 <span class="keywordtype">bool</span> <a class="code" href="classSturmTriggsSolver.html">SturmTriggsSolver&lt;M&gt;::colCompare::operator ()</a>(<span class="keywordtype">int</span> j1, <span class="keywordtype">int</span> j2) {
<a name="l00269"></a>00269   <span class="keywordtype">int</span> i;
<a name="l00270"></a>00270   <span class="keywordtype">bool</span> b1, b2;
<a name="l00271"></a>00271 
<a name="l00272"></a>00272   <span class="comment">// --- row 0 is MSB</span>
<a name="l00273"></a>00273   b1 = <span class="keyword">false</span>;
<a name="l00274"></a>00274   b2 = <span class="keyword">false</span>;
<a name="l00275"></a>00275   <span class="keywordflow">for</span>(i = 0; i&lt;M; ++i) {
<a name="l00276"></a>00276     <span class="comment">// --- this is equivalent to b = b XOR g</span>
<a name="l00277"></a>00277     b1 = (b1 == measurement.pixel_is_occluded(i,j1));
<a name="l00278"></a>00278     b2 = (b2 == measurement.pixel_is_occluded(i,j2));
<a name="l00279"></a>00279     <span class="keywordflow">if</span>(!b1 &amp;&amp; b2) <span class="keywordflow">return</span>(<span class="keyword">true</span>);
<a name="l00280"></a>00280     <span class="keywordflow">if</span>(b1 &amp;&amp; !b2) <span class="keywordflow">return</span>(<span class="keyword">false</span>);
<a name="l00281"></a>00281   }
<a name="l00282"></a>00282 
<a name="l00283"></a>00283 
<a name="l00284"></a>00284   <span class="comment">// --- must be the equivalent</span>
<a name="l00285"></a>00285   <span class="keywordflow">return</span>(<span class="keyword">false</span>);
<a name="l00286"></a>00286 } 
<a name="l00287"></a>00287 
<a name="l00288"></a>00288 
<a name="l00291"></a>00291 <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> M&gt;
<a name="l00292"></a>00292 <span class="keywordtype">void</span> <a class="code" href="classSturmTriggsSolver.html">SturmTriggsSolver&lt;M&gt;::form_subspace</a>(std::vector&lt;int&gt;::iterator cBegin,
<a name="l00293"></a>00293                                          <a class="code" href="classMeasurementMatrix.html">MeasurementMatrix&lt;M&gt;</a> &amp;subspace) {
<a name="l00294"></a>00294   <span class="keywordtype">int</span>                           v,i,j,k;
<a name="l00295"></a>00295   std::vector&lt;int&gt;::iterator    cEnd = cBegin+4;
<a name="l00296"></a>00296   std::vector&lt;int&gt;::iterator    colIt;
<a name="l00297"></a>00297   Eigen::Matrix&lt;bool,M,4&gt;       soloPixel; <span class="comment">// single pixel on its own?</span>
<a name="l00298"></a>00298   Eigen::Matrix&lt;bool,M,1&gt;       occluded;
<a name="l00299"></a>00299   Eigen::Matrix&lt;int,M,1&gt;        colPosition;    
<a name="l00300"></a>00300   <span class="keywordtype">bool</span>                          updated;
<a name="l00301"></a>00301   <span class="keywordtype">int</span>                           colCount;
<a name="l00302"></a>00302   <span class="keywordtype">int</span>                           parent;
<a name="l00303"></a>00303 
<a name="l00304"></a>00304   colCount = 0;
<a name="l00305"></a>00305 
<a name="l00306"></a>00306   <span class="comment">// --- First calculate occlusions</span>
<a name="l00307"></a>00307   <span class="comment">// --- occluded     - true if row is occluded</span>
<a name="l00308"></a>00308   <span class="keywordflow">for</span>(i = 0; i&lt;M; ++i) {
<a name="l00309"></a>00309     occluded(i) = <span class="keyword">false</span>;
<a name="l00310"></a>00310     <span class="keywordflow">for</span>(colIt = cBegin; colIt != cEnd; ++colIt) {
<a name="l00311"></a>00311       <span class="keywordflow">if</span>(measurement.pixel_is_occluded(i,*colIt) &amp;&amp; !occluded(i)) {
<a name="l00312"></a>00312         occluded(i) = <span class="keyword">true</span>;
<a name="l00313"></a>00313         colCount += 3;
<a name="l00314"></a>00314       }
<a name="l00315"></a>00315     }    
<a name="l00316"></a>00316   }
<a name="l00317"></a>00317 
<a name="l00318"></a>00318   <span class="comment">// --- Now find positions of columns</span>
<a name="l00319"></a>00319   <span class="comment">// --- with one pixel on its own.</span>
<a name="l00320"></a>00320   soloPixel.fill(<span class="keyword">false</span>);
<a name="l00321"></a>00321   <span class="keywordflow">for</span>(v = 0; v&lt;M; ++v) {
<a name="l00322"></a>00322     i = tree_traversal(v);
<a name="l00323"></a>00323     <span class="keywordflow">if</span>(!occluded(i)) {
<a name="l00324"></a>00324       j = 0;
<a name="l00325"></a>00325       <span class="keywordflow">for</span>(colIt = cBegin; colIt != cEnd; ++colIt) {
<a name="l00326"></a>00326         <span class="keywordflow">if</span>(spanning_tree(i) == -1 || occluded(spanning_tree(i))) {
<a name="l00327"></a>00327           soloPixel(i,j) = <span class="keyword">true</span>;
<a name="l00328"></a>00328           colCount += 1;
<a name="l00329"></a>00329         } <span class="keywordflow">else</span> {
<a name="l00330"></a>00330           soloPixel(spanning_tree(i),j) = <span class="keyword">false</span>;
<a name="l00331"></a>00331         }
<a name="l00332"></a>00332         ++j;
<a name="l00333"></a>00333       }
<a name="l00334"></a>00334     }
<a name="l00335"></a>00335   }
<a name="l00336"></a>00336 
<a name="l00337"></a>00337   <span class="comment">// --- remove redundant solo-pixel expansions</span>
<a name="l00338"></a>00338   <span class="comment">// --- (4 x solo pixels in one row)</span>
<a name="l00339"></a>00339   <span class="keywordflow">for</span>(i = 0; i&lt;M; ++i) {
<a name="l00340"></a>00340     <span class="keywordflow">if</span>(!occluded(i) &amp;&amp;
<a name="l00341"></a>00341        soloPixel.row(i) == Eigen::Matrix&lt;bool,1,4&gt;(<span class="keyword">true</span>,<span class="keyword">true</span>,<span class="keyword">true</span>,<span class="keyword">true</span>)) {
<a name="l00342"></a>00342       occluded(i) = <span class="keyword">true</span>;
<a name="l00343"></a>00343       colCount -= 1;
<a name="l00344"></a>00344     }
<a name="l00345"></a>00345   }
<a name="l00346"></a>00346   
<a name="l00347"></a>00347   <span class="comment">// std::cout &lt;&lt; "Occluded = " &lt;&lt; occluded.transpose() &lt;&lt; std::endl;</span>
<a name="l00348"></a>00348   <span class="comment">// std::cout &lt;&lt; "Solo pixels = " &lt;&lt; std::endl &lt;&lt; soloPixel &lt;&lt; std::endl;</span>
<a name="l00349"></a>00349   <span class="comment">// std::cout &lt;&lt; "ColCount = " &lt;&lt; colCount &lt;&lt; std::endl;</span>
<a name="l00350"></a>00350 
<a name="l00351"></a>00351   <span class="comment">// --- now create subspace</span>
<a name="l00352"></a>00352   <span class="comment">// --- column by column</span>
<a name="l00353"></a>00353   subspace.resize(3*M, colCount);
<a name="l00354"></a>00354   subspace.setZero();
<a name="l00355"></a>00355   j = 0;
<a name="l00356"></a>00356   <span class="keywordflow">for</span>(colIt = cBegin; colIt != cEnd; ++colIt) {
<a name="l00357"></a>00357     <span class="keywordflow">for</span>(v = 0; v&lt;M; ++v) {
<a name="l00358"></a>00358       i = tree_traversal(v);
<a name="l00359"></a>00359       <span class="keywordflow">if</span>(!occluded(i)) {
<a name="l00360"></a>00360         parent = spanning_tree(i);
<a name="l00361"></a>00361         <span class="keywordflow">if</span>(parent == -1 || occluded(parent)) {
<a name="l00362"></a>00362           <span class="comment">// --- start a new column</span>
<a name="l00363"></a>00363           subspace.<a class="code" href="classMeasurementMatrix.html#976bed12b8bacb9648d8e0e3265c2968">pixel</a>(i,j) = measurement.pixel(i,*colIt);
<a name="l00364"></a>00364           colPosition(i) = j;
<a name="l00365"></a>00365           updated = <span class="keyword">true</span>;
<a name="l00366"></a>00366           ++j;
<a name="l00367"></a>00367         } <span class="keywordflow">else</span> {
<a name="l00368"></a>00368           <span class="comment">// --- add to an existing column</span>
<a name="l00369"></a>00369           colPosition(i) = colPosition(parent);
<a name="l00370"></a>00370           subspace.<a class="code" href="classMeasurementMatrix.html#976bed12b8bacb9648d8e0e3265c2968">pixel</a>(i,colPosition(i)) = measurement.pixel(i,*colIt);
<a name="l00371"></a>00371           updated = <span class="keyword">true</span>;
<a name="l00372"></a>00372         }
<a name="l00373"></a>00373       }
<a name="l00374"></a>00374     }
<a name="l00375"></a>00375   }
<a name="l00376"></a>00376 
<a name="l00377"></a>00377   <span class="comment">//--- now add occlusion expansions</span>
<a name="l00378"></a>00378   <span class="keywordflow">for</span>(i = 0; i&lt;M; ++i) {
<a name="l00379"></a>00379     <span class="keywordflow">if</span>(occluded(i)) {
<a name="l00380"></a>00380       subspace.template block&lt;3,3&gt;(3*i,j).setIdentity();
<a name="l00381"></a>00381       j += 3;
<a name="l00382"></a>00382     }
<a name="l00383"></a>00383   }
<a name="l00384"></a>00384 }
<a name="l00385"></a>00385 
<a name="l00386"></a>00386 
<a name="l00390"></a>00390 <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> M&gt;
<a name="l00391"></a><a class="code" href="classSturmTriggsSolver.html#1d01bcc1c1ef42701620a90e4b3a3290">00391</a> <span class="keywordtype">void</span> <a class="code" href="classSturmTriggsSolver.html#1d01bcc1c1ef42701620a90e4b3a3290">SturmTriggsSolver&lt;M&gt;::random_permute</a>(std::vector&lt;int&gt; &amp;p) {
<a name="l00392"></a>00392   <span class="keywordtype">int</span> i,j,d;
<a name="l00393"></a>00393   
<a name="l00394"></a>00394 
<a name="l00395"></a>00395   <span class="keywordflow">for</span>(i=0; i&lt;p.size()-1; ++i) {
<a name="l00396"></a>00396     j = i + 1 + (int)((p.size()-i-1)*(rand()*(1.0 - 1e-8)/RAND_MAX));
<a name="l00397"></a>00397     d = p[j];
<a name="l00398"></a>00398     p[j] = p[i];
<a name="l00399"></a>00399     p[i] = d;
<a name="l00400"></a>00400   }
<a name="l00401"></a>00401 }
<a name="l00402"></a>00402 
<a name="l00403"></a>00403 
<a name="l00407"></a>00407 <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> M&gt;
<a name="l00408"></a><a class="code" href="classSturmTriggsSolver.html#1e4d064b50910113954e779a2bb1ea5f">00408</a> <span class="keywordtype">void</span> <a class="code" href="classSturmTriggsSolver.html#1e4d064b50910113954e779a2bb1ea5f">SturmTriggsSolver&lt;M&gt;::set_measurement_matrix</a>(<span class="keyword">const</span> <a class="code" href="classMeasurementMatrix.html">MeasurementMatrix&lt;M&gt;</a> &amp;E) {
<a name="l00409"></a>00409   <a class="code" href="classAdjacencyMatrix.html">AdjacencyMatrix&lt;M&gt;</a>            view_connections;   <span class="comment">// graph of views</span>
<a name="l00410"></a>00410   Eigen::Matrix&lt;bool,M,1&gt;       visited;            <span class="comment">// has this view been visited</span>
<a name="l00411"></a>00411   <span class="keywordtype">int</span>                           v,i;
<a name="l00412"></a>00412   <span class="keywordtype">int</span>                           treeRoot;
<a name="l00413"></a>00413   <span class="keywordtype">bool</span>                          updated;
<a name="l00414"></a>00414 
<a name="l00415"></a>00415   measurement = E;
<a name="l00416"></a>00416 
<a name="l00417"></a>00417   <a class="code" href="classSturmTriggsSolver.html#f9c8874c96e7189a154cef6bae5c60bc">create_connectivity_graph</a>(view_connections);
<a name="l00418"></a>00418   view_connections.<a class="code" href="classAdjacencyMatrix.html#0ff50eaad74dd681ef8aaf16239faeb4">shortest_spanning_tree</a>(treeRoot, spanning_tree);
<a name="l00419"></a>00419   std::cout &lt;&lt; <span class="stringliteral">"Spanning tree = "</span> &lt;&lt; std::endl &lt;&lt; spanning_tree &lt;&lt; std::endl; 
<a name="l00420"></a>00420   visited.fill(<span class="keyword">false</span>);
<a name="l00421"></a>00421   visited(treeRoot) = <span class="keyword">true</span>;
<a name="l00422"></a>00422   tree_traversal(0) = treeRoot;
<a name="l00423"></a>00423   v = 1;
<a name="l00424"></a>00424   <span class="keywordflow">do</span> {
<a name="l00425"></a>00425     updated = <span class="keyword">false</span>;    
<a name="l00426"></a>00426     <span class="keywordflow">for</span>(i = 0; i&lt;M; ++i) {
<a name="l00427"></a>00427       <span class="keywordflow">if</span>(!visited(i) &amp;&amp; visited(spanning_tree(i))) {
<a name="l00428"></a>00428         tree_traversal(v++) = i;
<a name="l00429"></a>00429         visited(i) = <span class="keyword">true</span>;
<a name="l00430"></a>00430         updated = <span class="keyword">true</span>;
<a name="l00431"></a>00431       }
<a name="l00432"></a>00432     }
<a name="l00433"></a>00433   } <span class="keywordflow">while</span>(updated);
<a name="l00434"></a>00434 }
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Jun 28 17:48:12 2012 for ProCamSolver by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
