<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>ProCamSolver: MeasurementMatrix&lt; M &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>MeasurementMatrix&lt; M &gt; Class Template Reference</h1><!-- doxytag: class="MeasurementMatrix" --><code>#include &lt;<a class="el" href="MeasurementMatrix_8h-source.html">MeasurementMatrix.h</a>&gt;</code>
<p>

<p>
<a href="classMeasurementMatrix-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bc5d9eab69a612ee3aaa7d824938e209"></a><!-- doxytag: member="MeasurementMatrix::Base" ref="bc5d9eab69a612ee3aaa7d824938e209" args="" -->
typedef Eigen::Matrix&lt; double, <br>
3 *M, Eigen::Dynamic &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>Base</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="215ce5587d9ecb2e31feb159b2424367"></a><!-- doxytag: member="MeasurementMatrix::PixelRef" ref="215ce5587d9ecb2e31feb159b2424367" args="" -->
typedef Eigen::Block&lt; Base, 3, 1 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>PixelRef</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="853f9a7b5bce1fb32626f12257c24ac2"></a><!-- doxytag: member="MeasurementMatrix::constPixelRef" ref="853f9a7b5bce1fb32626f12257c24ac2" args="" -->
typedef const Eigen::Block<br>
&lt; const Base, 3, 1 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>constPixelRef</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="950934e2fa358097d4237f7ee15a230d"></a><!-- doxytag: member="MeasurementMatrix::ColXpr" ref="950934e2fa358097d4237f7ee15a230d" args="" -->
typedef Base::ColXpr&nbsp;</td><td class="memItemRight" valign="bottom"><b>ColXpr</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="11caf8ab1ea61d7268be50c9f169ce55"></a><!-- doxytag: member="MeasurementMatrix::ColsBlockXpr" ref="11caf8ab1ea61d7268be50c9f169ce55" args="" -->
typedef Base::ColsBlockXpr&nbsp;</td><td class="memItemRight" valign="bottom"><b>ColsBlockXpr</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="47527b0bdd44bc4db50f6f608a567744"></a><!-- doxytag: member="MeasurementMatrix::ViewRef" ref="47527b0bdd44bc4db50f6f608a567744" args="" -->
typedef Base::RowsBlockXpr&nbsp;</td><td class="memItemRight" valign="bottom"><b>ViewRef</b></td></tr>

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeasurementMatrix.html#2830b09d0a38fe774ceac57c2436fc25">MeasurementMatrix</a> (const <a class="el" href="classCorrespondenceSet.html">CorrespondenceSet</a> &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeasurementMatrix.html#358011dcd5519fa9fc39a56f9386e964">add_correspondence</a> (const <a class="el" href="classCorrespondence.html">Correspondence</a> &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeasurementMatrix.html#01e119caefd759f2b9a2e65ce7c2dcc6">load</a> (const char *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeasurementMatrix.html#9823bc472bb1e95a7019af8d2c2782a7">normalise</a> (<a class="el" href="classImageTransform.html">ImageTransform</a>&lt; M &gt; &amp;, bool fixedAspect=false)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeasurementMatrix.html#50bb8f66a31065040fd1be6964fbfe5e">unscale</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeasurementMatrix.html#17df03814e515221ffafb893c47e70e7">scale_and_fill</a> (const <a class="el" href="classMotionMatrix.html">MotionMatrix</a>&lt; M &gt; &amp;, const <a class="el" href="classShapeMatrix.html">ShapeMatrix</a> &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeasurementMatrix.html#a1d9a47c20c0e2da3d09a1cfa64eddb5">synthesise_measurements</a> (const <a class="el" href="classMotionMatrix.html">MotionMatrix</a>&lt; M &gt; &amp;, int, double)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeasurementMatrix.html#f85e926f3c754f12ef699dc9a0961e47">synthesise_occlusions</a> (double)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="99e8fea7867a305f61c6f0ae1ff1f771"></a><!-- doxytag: member="MeasurementMatrix::order_cols_by_occlusions" ref="99e8fea7867a305f61c6f0ae1ff1f771" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>order_cols_by_occlusions</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">PixelRef&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeasurementMatrix.html#976bed12b8bacb9648d8e0e3265c2968">pixel</a> (int, int)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6770758c551fa1a788e84399589f7f60"></a><!-- doxytag: member="MeasurementMatrix::pixel" ref="6770758c551fa1a788e84399589f7f60" args="(int, int) const " -->
constPixelRef&nbsp;</td><td class="memItemRight" valign="bottom"><b>pixel</b> (int, int) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeasurementMatrix.html#a5f1f98d7fc2d7862be7c2309fafb7b2">pixel_is_occluded</a> (int, int) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">ViewRef&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeasurementMatrix.html#dadbcfb5d897ec52ed11d5c5eda59855">view</a> (int)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeasurementMatrix.html#c66ccaf22bcef4e339ffe9d6c98a103b">insert_pixel</a> (int, const <a class="el" href="classGPixel.html">GPixel</a> &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeasurementMatrix.html#e6dc25c2b3aa8eeab7b19dfc36d87051">merge_columns</a> (int, int)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeasurementMatrix.html#a93cbb8a0ae1936a512a9fd93ed149af">new_column</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeasurementMatrix.html#05d194eb20237c7c874213c74819754b">new_columns</a> (int)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeasurementMatrix.html#ca516a2d496e1a22cdaa78a88b13c594">insert_columns</a> (ColsBlockXpr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeasurementMatrix.html#94d0b0016f655ffd1b395db41ebe1a59">insert_column_and_expand</a> (ColXpr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeasurementMatrix.html#c9e4c50f0453460de208067444dcf4cb">delete_column</a> (int)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeasurementMatrix.html#0052401400707b803be18b5334f6d699">delete_columns</a> (int, int)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeasurementMatrix.html#fd158fb3e361a3437aa4f04d36bc2fc2">column_containing</a> (const <a class="el" href="classGPixel.html">GPixel</a> &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeasurementMatrix.html#c7fe1b3d19b2186f10847a51d17d66ec">rank</a> (double=0.0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeasurementMatrix.html#1fd2d5bcf0da4f91f14f05fea1394072">is_fully_expanded</a> (int)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="2af154b0e7b87fbc557b5c873fe48d28"></a><!-- doxytag: member="MeasurementMatrix::operator=" ref="2af154b0e7b87fbc557b5c873fe48d28" args="(const Eigen::MatrixBase&lt; D &gt; &amp;)" -->
template&lt;class D&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classMeasurementMatrix.html">MeasurementMatrix</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator=</b> (const Eigen::MatrixBase&lt; D &gt; &amp;)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;int M&gt;<br>
 class MeasurementMatrix&lt; M &gt;</h3>

Class to represent the measurements of N 3D points from M views. As defined in Sturm, P. and Triggs, B. 1996: A factorization based algorithm for multi-image projective structure and motion. European conference on computer vision, 1996: 709-720. <hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="2830b09d0a38fe774ceac57c2436fc25"></a><!-- doxytag: member="MeasurementMatrix::MeasurementMatrix" ref="2830b09d0a38fe774ceac57c2436fc25" args="(const CorrespondenceSet &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMeasurementMatrix.html">MeasurementMatrix</a>&lt; M &gt;::<a class="el" href="classMeasurementMatrix.html">MeasurementMatrix</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCorrespondenceSet.html">CorrespondenceSet</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>corrs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets *this to contain the given set of corrrespondences. Use this constructor in favour of add_correspondece if you have a large number of correspondences as insertion into a <a class="el" href="classCorrespondenceSet.html">CorrespondenceSet</a> is much quicker. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="358011dcd5519fa9fc39a56f9386e964"></a><!-- doxytag: member="MeasurementMatrix::add_correspondence" ref="358011dcd5519fa9fc39a56f9386e964" args="(const Correspondence &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classMeasurementMatrix.html">MeasurementMatrix</a>&lt; M &gt;::add_correspondence           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCorrespondence.html">Correspondence</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>corr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a pixel correspondence to '*this'<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the index of the column that the correspondence was added to </dd></dl>

</div>
</div><p>
<a class="anchor" name="01e119caefd759f2b9a2e65ce7c2dcc6"></a><!-- doxytag: member="MeasurementMatrix::load" ref="01e119caefd759f2b9a2e65ce7c2dcc6" args="(const char *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMeasurementMatrix.html">MeasurementMatrix</a>&lt; M &gt;::load           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>filename</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Loads a set of pixel correspondences from a sorted file in the format &lt;id1&gt; &lt;id2&gt; &lt;x1&gt; &lt;y1&gt; &lt;x2&gt; &lt;y2&gt;<p>
This method assumes that:<p>
1) The views can be split into projectors and cameras<p>
2) &lt;id1&gt; is always a projector<p>
3) There are no direct correspondences between projectors<p>
4) The file is sorted by projector id and projector pixel coordinate<p>
where<p>
id1/2 = id of the projector / camera x1/2, y1/2 = pixel coordinate of the projector / camera 
</div>
</div><p>
<a class="anchor" name="9823bc472bb1e95a7019af8d2c2782a7"></a><!-- doxytag: member="MeasurementMatrix::normalise" ref="9823bc472bb1e95a7019af8d2c2782a7" args="(ImageTransform&lt; M &gt; &amp;, bool fixedAspect=false)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMeasurementMatrix.html">MeasurementMatrix</a>&lt; M &gt;::normalise           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classImageTransform.html">ImageTransform</a>&lt; M &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>denormalisation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>fixedAspect</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Normalises *this by setting the scales of all un-occluded pixels to 1.0, offsetting the pixels so that the mean of pixels in each view is (0,0) and scaling the (x,y) values so that the standard deviation in each view is 1. If 'fixedAspect' is false (the default) then the standard deviation in both x and y directions is set to 1, otherwise the sum of x and y variances is 1<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>denormalisation</em>&nbsp;</td><td>This is set to the inverse transform for subsequent de-normalisation.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fixedAspect</em>&nbsp;</td><td>If true, aspect ratio is held fixed (default is false). </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="50bb8f66a31065040fd1be6964fbfe5e"></a><!-- doxytag: member="MeasurementMatrix::unscale" ref="50bb8f66a31065040fd1be6964fbfe5e" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMeasurementMatrix.html">MeasurementMatrix</a>&lt; M &gt;::unscale           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes scaling from *this by multiplying each pixel, p, by 1/p(2) i.e. by setting the homogeneos coord to z=1.0. Pixels with scale = 0.0 are assumed to be occluded and so are unchanged 
</div>
</div><p>
<a class="anchor" name="17df03814e515221ffafb893c47e70e7"></a><!-- doxytag: member="MeasurementMatrix::scale_and_fill" ref="17df03814e515221ffafb893c47e70e7" args="(const MotionMatrix&lt; M &gt; &amp;, const ShapeMatrix &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMeasurementMatrix.html">MeasurementMatrix</a>&lt; M &gt;::scale_and_fill           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMotionMatrix.html">MotionMatrix</a>&lt; M &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classShapeMatrix.html">ShapeMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Scales the pixels of *this and fills in occluded pixels based on the given motion matrix and shape matrix. Scale is calculated as lambda = P.row(2)X 
</div>
</div><p>
<a class="anchor" name="a1d9a47c20c0e2da3d09a1cfa64eddb5"></a><!-- doxytag: member="MeasurementMatrix::synthesise_measurements" ref="a1d9a47c20c0e2da3d09a1cfa64eddb5" args="(const MotionMatrix&lt; M &gt; &amp;, int, double)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMeasurementMatrix.html">MeasurementMatrix</a>&lt; M &gt;::synthesise_measurements           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMotionMatrix.html">MotionMatrix</a>&lt; M &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>pts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>noise</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Synthesises a set of pixel correspondences based on a random set of 'pts' 3D-points and a given motion matrix. A random noise of amplitude given by 'noise' is added to the pixels.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>The motion matrix defining the position and orientation of the cameras</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pts</em>&nbsp;</td><td>The number of 3D points to synthesize data for</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>noise</em>&nbsp;</td><td>The amplitude of noise to add to the pixel measurements </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f85e926f3c754f12ef699dc9a0961e47"></a><!-- doxytag: member="MeasurementMatrix::synthesise_occlusions" ref="f85e926f3c754f12ef699dc9a0961e47" args="(double)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMeasurementMatrix.html">MeasurementMatrix</a>&lt; M &gt;::synthesise_occlusions           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>proportion</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Synthesises occlusions in this measurement matrix by randomly replacing some of the pixels with zero. Each pixel has a 'proportion' probability of being occluded. 
</div>
</div><p>
<a class="anchor" name="976bed12b8bacb9648d8e0e3265c2968"></a><!-- doxytag: member="MeasurementMatrix::pixel" ref="976bed12b8bacb9648d8e0e3265c2968" args="(int, int)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMeasurementMatrix.html">MeasurementMatrix</a>&lt; M &gt;::PixelRef <a class="el" href="classMeasurementMatrix.html">MeasurementMatrix</a>&lt; M &gt;::pixel           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>point</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Provides access to individual pixels within this matrix.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>view</em>&nbsp;</td><td>The view of the pixel (i.e. row index/3) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>point</em>&nbsp;</td><td>The 3D point of the pixel (i.e. column index)</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>reference to a 3x1 block containing the pixel </dd></dl>

</div>
</div><p>
<a class="anchor" name="a5f1f98d7fc2d7862be7c2309fafb7b2"></a><!-- doxytag: member="MeasurementMatrix::pixel_is_occluded" ref="a5f1f98d7fc2d7862be7c2309fafb7b2" args="(int, int) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMeasurementMatrix.html">MeasurementMatrix</a>&lt; M &gt;::pixel_is_occluded           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>point</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
true if the given pixel of the given view is occluded (i.e. the scale is zero). 
</div>
</div><p>
<a class="anchor" name="dadbcfb5d897ec52ed11d5c5eda59855"></a><!-- doxytag: member="MeasurementMatrix::view" ref="dadbcfb5d897ec52ed11d5c5eda59855" args="(int)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMeasurementMatrix.html">MeasurementMatrix</a>&lt; M &gt;::ViewRef <a class="el" href="classMeasurementMatrix.html">MeasurementMatrix</a>&lt; M &gt;::view           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns all pixel measurements from a given view, in the form of a 3 x N matrix, where N is the number of 3D points and each column contains a pixel. Some columns may be zero, meaning there are no measurements for this point from the given view. 
</div>
</div><p>
<a class="anchor" name="c66ccaf22bcef4e339ffe9d6c98a103b"></a><!-- doxytag: member="MeasurementMatrix::insert_pixel" ref="c66ccaf22bcef4e339ffe9d6c98a103b" args="(int, const GPixel &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMeasurementMatrix.html">MeasurementMatrix</a>&lt; M &gt;::insert_pixel           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGPixel.html">GPixel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inserts a Gpixel in the correct row of the 'col'th column <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>col</em>&nbsp;</td><td>the column (3d point) to insert the pixel in </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>the global pixel to insert </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e6dc25c2b3aa8eeab7b19dfc36d87051"></a><!-- doxytag: member="MeasurementMatrix::merge_columns" ref="e6dc25c2b3aa8eeab7b19dfc36d87051" args="(int, int)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMeasurementMatrix.html">MeasurementMatrix</a>&lt; M &gt;::merge_columns           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>j1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>j2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Merges measurements from two different 3D points into one 3D point by copying pixels in column j2 into the undefined portions of j1, then deleting j2 
</div>
</div><p>
<a class="anchor" name="a93cbb8a0ae1936a512a9fd93ed149af"></a><!-- doxytag: member="MeasurementMatrix::new_column" ref="a93cbb8a0ae1936a512a9fd93ed149af" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classMeasurementMatrix.html">MeasurementMatrix</a>&lt; M &gt;::new_column           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a new column to '*this', corresponding to measurements of a new 3D point<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the index of the new column </dd></dl>

</div>
</div><p>
<a class="anchor" name="05d194eb20237c7c874213c74819754b"></a><!-- doxytag: member="MeasurementMatrix::new_columns" ref="05d194eb20237c7c874213c74819754b" args="(int)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classMeasurementMatrix.html">MeasurementMatrix</a>&lt; M &gt;::new_columns           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
inserts 'n' new columns into *this.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>index of the left-most column inserted </dd></dl>

</div>
</div><p>
<a class="anchor" name="ca516a2d496e1a22cdaa78a88b13c594"></a><!-- doxytag: member="MeasurementMatrix::insert_columns" ref="ca516a2d496e1a22cdaa78a88b13c594" args="(ColsBlockXpr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classMeasurementMatrix.html">MeasurementMatrix</a>&lt; M &gt;::insert_columns           </td>
          <td>(</td>
          <td class="paramtype">ColsBlockXpr&nbsp;</td>
          <td class="paramname"> <em>c</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inserts a number of columns into *this<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>index of the first column added </dd></dl>

</div>
</div><p>
<a class="anchor" name="94d0b0016f655ffd1b395db41ebe1a59"></a><!-- doxytag: member="MeasurementMatrix::insert_column_and_expand" ref="94d0b0016f655ffd1b395db41ebe1a59" args="(ColXpr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classMeasurementMatrix.html">MeasurementMatrix</a>&lt; M &gt;::insert_column_and_expand           </td>
          <td>(</td>
          <td class="paramtype">ColXpr&nbsp;</td>
          <td class="paramname"> <em>c</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inserts the column 'c' into *this and applies a number of expansions to form a subspace matrix, as described in Martinec, D. and Pajdla, T. 2002: Structire from many perspective images with occlusions. ECCV 2002, LNCS 2351:355-369.<p>
There are two types of expansion, each of which can be applied to a view (i.e. 3 rows, corresponding to the 3 rows of a pixel)<p>
<ul>
<li>Pixel expansion: a pixel in 'c' is moved into a new column that has all other pixels set to zero, the original column is set to zero in that pixel position</li></ul>
<p>
<ul>
<li>Full expansion: Three new columns are added that have zeroes in all pixels apart from one, which have the values (1,0,0)^T, (0,1,0)^T and (0,0,1)^T respectively.</li></ul>
<p>
Full expansion is applied to each view in 'c' that has a missing pixel (flagged by a 0.0 in the third row of the pixel), unless that view has already been fully expanded. Pixel expansion is applied to each view in 'c' that has an unweighted pixel (flagged by a 1.0 in the third row of the pixel), unless that view has already been fully expanded.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the index of the leftmost column that was inserted. The inserted columns are always the rightmost columns. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c9e4c50f0453460de208067444dcf4cb"></a><!-- doxytag: member="MeasurementMatrix::delete_column" ref="c9e4c50f0453460de208067444dcf4cb" args="(int)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMeasurementMatrix.html">MeasurementMatrix</a>&lt; M &gt;::delete_column           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes column 'i' from this matrix 
</div>
</div><p>
<a class="anchor" name="0052401400707b803be18b5334f6d699"></a><!-- doxytag: member="MeasurementMatrix::delete_columns" ref="0052401400707b803be18b5334f6d699" args="(int, int)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMeasurementMatrix.html">MeasurementMatrix</a>&lt; M &gt;::delete_columns           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes columns 'i' to i+n from this matrix 
</div>
</div><p>
<a class="anchor" name="fd158fb3e361a3437aa4f04d36bc2fc2"></a><!-- doxytag: member="MeasurementMatrix::column_containing" ref="fd158fb3e361a3437aa4f04d36bc2fc2" args="(const GPixel &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classMeasurementMatrix.html">MeasurementMatrix</a>&lt; M &gt;::column_containing           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGPixel.html">GPixel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>G</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the index of the column contining the given global pixel, G, or -1 if no such column exists<p>
To avoid problems with rounding error, pixel coordinates that are closer than 10^-5 are treated as equal 
</div>
</div><p>
<a class="anchor" name="c7fe1b3d19b2186f10847a51d17d66ec"></a><!-- doxytag: member="MeasurementMatrix::rank" ref="c7fe1b3d19b2186f10847a51d17d66ec" args="(double=0.0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classMeasurementMatrix.html">MeasurementMatrix</a>&lt; M &gt;::rank           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>threshold</em> = <code>0.0</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of singular values of *this whose absolute value is greater than s1*'threshold' where s1 is the absolute value of the first singular value. 
</div>
</div><p>
<a class="anchor" name="1fd2d5bcf0da4f91f14f05fea1394072"></a><!-- doxytag: member="MeasurementMatrix::is_fully_expanded" ref="1fd2d5bcf0da4f91f14f05fea1394072" args="(int)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMeasurementMatrix.html">MeasurementMatrix</a>&lt; M &gt;::is_fully_expanded           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>view</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
True if the given view in *this has been fully expanded during formation of a subspace matrix when accounting for occlusions. Works by looking for a (1,x,0)^T pixel in 'view', which shouldn't exist in a subspace matrix unless expanded. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="MeasurementMatrix_8h-source.html">MeasurementMatrix.h</a><li><a class="el" href="MeasurementMatrix_8hpp-source.html">MeasurementMatrix.hpp</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Jun 28 17:48:12 2012 for ProCamSolver by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
