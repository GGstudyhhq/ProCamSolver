<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>ProCamSolver: MotionMatrix&lt; VIEWS &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>MotionMatrix&lt; VIEWS &gt; Class Template Reference</h1><!-- doxytag: class="MotionMatrix" --><code>#include &lt;<a class="el" href="MotionMatrix_8h-source.html">MotionMatrix.h</a>&gt;</code>
<p>

<p>
<a href="classMotionMatrix-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c6c8bfe70a93ce33ed9fe497eb7d564f"></a><!-- doxytag: member="MotionMatrix::Base" ref="c6c8bfe70a93ce33ed9fe497eb7d564f" args="" -->
typedef Eigen::Matrix&lt; double, <br>
3 *VIEWS, 4 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>Base</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f52f4e30a3d4f42939f9e31efa448a12"></a><!-- doxytag: member="MotionMatrix::Block34" ref="f52f4e30a3d4f42939f9e31efa448a12" args="" -->
typedef Eigen::Block&lt; Base, 3, 4 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>Block34</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1e6c0925509f8d5bb8dd153ced02f29b"></a><!-- doxytag: member="MotionMatrix::Block33" ref="1e6c0925509f8d5bb8dd153ced02f29b" args="" -->
typedef Eigen::Block&lt; Base, 3, 3 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>Block33</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0af37eaab7d9c3a2efcf9c70c09f4054"></a><!-- doxytag: member="MotionMatrix::Block31" ref="0af37eaab7d9c3a2efcf9c70c09f4054" args="" -->
typedef Eigen::Block&lt; Base, 3, 1 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>Block31</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c7dfb25e6695630de9945c908057079c"></a><!-- doxytag: member="MotionMatrix::constBlock34" ref="c7dfb25e6695630de9945c908057079c" args="" -->
typedef const Eigen::Block<br>
&lt; const Base, 3, 4 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>constBlock34</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="343adbbbddb8810eaa90e590b400f223"></a><!-- doxytag: member="MotionMatrix::constBlock33" ref="343adbbbddb8810eaa90e590b400f223" args="" -->
typedef const Eigen::Block<br>
&lt; const Base, 3, 3 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>constBlock33</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5439552fa8451d70d80449afd63e337c"></a><!-- doxytag: member="MotionMatrix::constBlock31" ref="5439552fa8451d70d80449afd63e337c" args="" -->
typedef const Eigen::Block<br>
&lt; const Base, 3, 1 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>constBlock31</b></td></tr>

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Block34&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMotionMatrix.html#e6f06dec59a8f1bd8c511413b1ad5f02">view</a> (int)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a8384a256d5c685cbb4813c1c814b4d1"></a><!-- doxytag: member="MotionMatrix::view" ref="a8384a256d5c685cbb4813c1c814b4d1" args="(int) const " -->
constBlock34&nbsp;</td><td class="memItemRight" valign="bottom"><b>view</b> (int) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">Block33&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMotionMatrix.html#7b90bdd8270f9812277caf79b0c10f74">M</a> (int)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d50a78f7841e620db0dc5015a5364971"></a><!-- doxytag: member="MotionMatrix::M" ref="d50a78f7841e620db0dc5015a5364971" args="(int) const " -->
constBlock33&nbsp;</td><td class="memItemRight" valign="bottom"><b>M</b> (int) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">Block31&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMotionMatrix.html#966351f3c4caf06f7f3d920382993d8a">T</a> (int)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cc55b02b08128a3c68155582df844996"></a><!-- doxytag: member="MotionMatrix::T" ref="cc55b02b08128a3c68155582df844996" args="(int) const " -->
constBlock31&nbsp;</td><td class="memItemRight" valign="bottom"><b>T</b> (int) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMotionMatrix.html#5a07d5b1459cb42e191a3892c9c122ea">svd_solve</a> (const <a class="el" href="classMeasurementMatrix.html">MeasurementMatrix</a>&lt; VIEWS &gt; &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMotionMatrix.html#ba362a86aa78cfa72f6c4091903749fd">bundle_adjust</a> (int, const <a class="el" href="classMeasurementMatrix.html">MeasurementMatrix</a>&lt; VIEWS &gt; &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="01b3af95966bcd2486ef5507aa46597d"></a><!-- doxytag: member="MotionMatrix::diac_euclidean_lift" ref="01b3af95966bcd2486ef5507aa46597d" args="(int)" -->
Eigen::Matrix4d&nbsp;</td><td class="memItemRight" valign="bottom"><b>diac_euclidean_lift</b> (int)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;int F&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Eigen::Matrix4d&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMotionMatrix.html#721d51dcf3780ba680e2b4041ab746f1">diac_euclidean_lift</a> (int, const <a class="el" href="classImageTransform.html">ImageTransform</a>&lt; F &gt; &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">Eigen::Matrix4d&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMotionMatrix.html#594bcbe24554b8d7f2d67100195154bf">euclidean_lift</a> (const Eigen::Vector3d &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">Eigen::Vector3d&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMotionMatrix.html#9699480741b7eb3c15d4002bcede5648">plane_at_infinity</a> (int)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMotionMatrix.html#fdd77376ffc6baf6248f239ff90e8400">KR_decompose</a> (<a class="el" href="classImageTransform.html">ImageTransform</a>&lt; VIEWS &gt; &amp;, <a class="el" href="classImageTransform.html">ImageTransform</a>&lt; VIEWS &gt; &amp;) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMotionMatrix.html#59d346810ed72e4f3e1646fee68c366c">KR_decompose</a> (int, Eigen::Affine2d &amp;, Eigen::AngleAxisd &amp;) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMotionMatrix.html#92a5815802fd8c0b9d7bb4a9bce7774c">reprojection_err</a> (const <a class="el" href="classMeasurementMatrix.html">MeasurementMatrix</a>&lt; VIEWS &gt; &amp;, Eigen::VectorXd &amp;)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="88310e26d680fc8e00a0ec1e5d8719ef"></a><!-- doxytag: member="MotionMatrix::operator=" ref="88310e26d680fc8e00a0ec1e5d8719ef" args="(const Eigen::MatrixBase&lt; D &gt; &amp;)" -->
template&lt;class D&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classMotionMatrix.html">MotionMatrix</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator=</b> (const Eigen::MatrixBase&lt; D &gt; &amp;)</td></tr>

<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMotionMatrix.html#4bd28ac2a8594f875eca6bf64f2c352e">quadratic_prod</a> (const Eigen::Vector4d &amp;, const Eigen::Vector4d &amp;, typename Eigen::Matrix&lt; double, Eigen::Dynamic, 10 &gt;::RowXpr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f685fc24bc912240b77e2902fd130205"></a><!-- doxytag: member="MotionMatrix::quadratic_prod" ref="f685fc24bc912240b77e2902fd130205" args="(const Eigen::Vector3d &amp;, const Eigen::Vector3d &amp;, typename Eigen::Matrix&lt; double, 2 *VIEWS+1, 6 &gt;::RowXpr)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>quadratic_prod</b> (const Eigen::Vector3d &amp;, const Eigen::Vector3d &amp;, typename Eigen::Matrix&lt; double, 2 *VIEWS+1, 6 &gt;::RowXpr)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;int VIEWS&gt;<br>
 class MotionMatrix&lt; VIEWS &gt;</h3>

Class to represent a set of projective camera matrices. The matrices are placed one on top of the other into a 'projective motion matrix' as described in Sturm, P. and Triggs, B. 1996: A factorization based algorithm for multi-image projective structure and motion. European conference on computer vision, 1996: 709-720.<p>
The template parameter gives the number of cameras/projectors represented in this matrix. <hr><h2>Member Function Documentation</h2>
<a class="anchor" name="e6f06dec59a8f1bd8c511413b1ad5f02"></a><!-- doxytag: member="MotionMatrix::view" ref="e6f06dec59a8f1bd8c511413b1ad5f02" args="(int)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMotionMatrix.html">MotionMatrix</a>&lt; V &gt;::Block34 <a class="el" href="classMotionMatrix.html">MotionMatrix</a>&lt; V &gt;::view           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
returns a refrence to the v'th camera matrix 
</div>
</div><p>
<a class="anchor" name="7b90bdd8270f9812277caf79b0c10f74"></a><!-- doxytag: member="MotionMatrix::M" ref="7b90bdd8270f9812277caf79b0c10f74" args="(int)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMotionMatrix.html">MotionMatrix</a>&lt; V &gt;::Block33 <a class="el" href="classMotionMatrix.html">MotionMatrix</a>&lt; V &gt;::M           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
returns a refrence to the first 3 columns of the v'th camera matrix 
</div>
</div><p>
<a class="anchor" name="966351f3c4caf06f7f3d920382993d8a"></a><!-- doxytag: member="MotionMatrix::T" ref="966351f3c4caf06f7f3d920382993d8a" args="(int)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMotionMatrix.html">MotionMatrix</a>&lt; V &gt;::Block31 <a class="el" href="classMotionMatrix.html">MotionMatrix</a>&lt; V &gt;::T           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
returns a refrence to the last column of the v'th camera matrix 
</div>
</div><p>
<a class="anchor" name="5a07d5b1459cb42e191a3892c9c122ea"></a><!-- doxytag: member="MotionMatrix::svd_solve" ref="5a07d5b1459cb42e191a3892c9c122ea" args="(const MeasurementMatrix&lt; VIEWS &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMotionMatrix.html">MotionMatrix</a>&lt; V &gt;::svd_solve           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMeasurementMatrix.html">MeasurementMatrix</a>&lt; V &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>measurement</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculate the motion matrix from the given measurement matrix, holding some or none of the camera intrinsics fixed. No initial guess of this motion matrix is necessary.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>E</em>&nbsp;</td><td>The measurement matrix containing the pixel correspondences to be fitted. The measurement matrix may contain occlusions and need not be scaled.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fixedIntrinsics</em>&nbsp;</td><td>A transformation matrix containing the intrinsics of the cameras that have already been calibrated (if any). If this parameter is missing, all intrinsics are variable.</td></tr>
  </table>
</dl>
The following method is used:<p>
1) Calculate projective depths from the Fundamental matrices (Sturm and Triggs 1996)<p>
2) Approximate the shape/motion matrices using method of Martinec and Pajdla (2002)<p>
3) Use the approximate motion matrix to fill in occlusions and unknown projective depths<p>
4) Take Singular Value Decomposition to factorise into shape/motion matrices 
</div>
</div><p>
<a class="anchor" name="ba362a86aa78cfa72f6c4091903749fd"></a><!-- doxytag: member="MotionMatrix::bundle_adjust" ref="ba362a86aa78cfa72f6c4091903749fd" args="(int, const MeasurementMatrix&lt; VIEWS &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classMotionMatrix.html">MotionMatrix</a>&lt; V &gt;::bundle_adjust           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMeasurementMatrix.html">MeasurementMatrix</a>&lt; V &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>measurement</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Minimises reprojection error using bundle adjustment on Euclidean parameters (i.e. camera intrinsics/rotation/translation). 
</div>
</div><p>
<a class="anchor" name="721d51dcf3780ba680e2b4041ab746f1"></a><!-- doxytag: member="MotionMatrix::diac_euclidean_lift" ref="721d51dcf3780ba680e2b4041ab746f1" args="(int, const ImageTransform&lt; F &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int V&gt; </div>
<div class="memtemplate">
template&lt;int F&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix4d <a class="el" href="classMotionMatrix.html">MotionMatrix</a>&lt; V &gt;::diac_euclidean_lift           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nCameras</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classImageTransform.html">ImageTransform</a>&lt; F &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>fixedIntrinsics</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculates the projective transform that lifts this to a Euclidean form, i.e. so that each camera matrix can be expressed in the form K[R|t] where K is a camera intrinsic matrix, R is a rotation matrix and t is a translation. If the intrinsic matrices of some of the views are known, these can be supplied in fixedIntrinsics. The first 'F' views are then held fixed at the supplied values.<p>
The algorithm solves for the absolute dual quadric, on the assumption of zero skew, aspect ratio of 1 (i.e. pixels are square) and a principal point on the y axis. If aspect ratio is known and not 1, the camera matrices in *this can be left multiplied by [1 0 0] [0 a 0] [0 0 1] before euclidean lifting. and is described in Han and Kanade (2000).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nCameras</em>&nbsp;</td><td>The first 'nCameras' views are assumed to be cameras and so have principal points close to the origin</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fixedIntrinsics</em>&nbsp;</td><td>The intrinsic matrices of pre-calibrated views. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="594bcbe24554b8d7f2d67100195154bf"></a><!-- doxytag: member="MotionMatrix::euclidean_lift" ref="594bcbe24554b8d7f2d67100195154bf" args="(const Eigen::Vector3d &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix4d <a class="el" href="classMotionMatrix.html">MotionMatrix</a>&lt; V &gt;::euclidean_lift           </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3d &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Lift given plane at infinity and assuming zero skew and unit aspect ratio. Solves for the image of the absolute conic. 
</div>
</div><p>
<a class="anchor" name="9699480741b7eb3c15d4002bcede5648"></a><!-- doxytag: member="MotionMatrix::plane_at_infinity" ref="9699480741b7eb3c15d4002bcede5648" args="(int)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector3d <a class="el" href="classMotionMatrix.html">MotionMatrix</a>&lt; V &gt;::plane_at_infinity           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nCameras</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculates the plane at infinity 
</div>
</div><p>
<a class="anchor" name="fdd77376ffc6baf6248f239ff90e8400"></a><!-- doxytag: member="MotionMatrix::KR_decompose" ref="fdd77376ffc6baf6248f239ff90e8400" args="(ImageTransform&lt; VIEWS &gt; &amp;, ImageTransform&lt; VIEWS &gt; &amp;) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int VIEWS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classMotionMatrix.html">MotionMatrix</a>&lt; VIEWS &gt;::KR_decompose           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classImageTransform.html">ImageTransform</a>&lt; VIEWS &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classImageTransform.html">ImageTransform</a>&lt; VIEWS &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>R</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Splits *this into intrinsic / rotation matrices. *this should previously have been transformed to Euclidean. Works by calculating $MM^T$ where the camera matrix P = [M|T] and M = KR (see Han and Kanade, 2000)<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>K</em>&nbsp;</td><td>matrix to be filled with the camera intrinsics </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>R</em>&nbsp;</td><td>matrix to be filled with the camera rotation</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A measure of the extent that *this deviates from the Euclidean. This is calculated as the sum over all views of the absolute values of the skews, which should be zero for perfectly Euclidean cameras. </dd></dl>

</div>
</div><p>
<a class="anchor" name="59d346810ed72e4f3e1646fee68c366c"></a><!-- doxytag: member="MotionMatrix::KR_decompose" ref="59d346810ed72e4f3e1646fee68c366c" args="(int, Eigen::Affine2d &amp;, Eigen::AngleAxisd &amp;) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int VIEWS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classMotionMatrix.html">MotionMatrix</a>&lt; VIEWS &gt;::KR_decompose           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Affine2d &amp;&nbsp;</td>
          <td class="paramname"> <em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::AngleAxisd &amp;&nbsp;</td>
          <td class="paramname"> <em>R</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Extracts the intrinsic / rotation matrices from view 'v of this. Works by calculating $MM^T$ where the camera matrix P = [M|T] and M = sKR (see Han and Kanade, 2000) where s is a scaling factor, K is an upper triangular (i.e. intrinsics) matrix with 1.0 in the lower-right element and R is a rotation matrix<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>K</em>&nbsp;</td><td>affine Transform to be filled with the camera intrinsics </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>R</em>&nbsp;</td><td>AngleAxis to be filled with the camera rotation</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the scaling factor, s. </dd></dl>

</div>
</div><p>
<a class="anchor" name="92a5815802fd8c0b9d7bb4a9bce7774c"></a><!-- doxytag: member="MotionMatrix::reprojection_err" ref="92a5815802fd8c0b9d7bb4a9bce7774c" args="(const MeasurementMatrix&lt; VIEWS &gt; &amp;, Eigen::VectorXd &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMotionMatrix.html">MotionMatrix</a>&lt; V &gt;::reprojection_err           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMeasurementMatrix.html">MeasurementMatrix</a>&lt; V &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculates the reprojection error of *this compared to E 
</div>
</div><p>
<a class="anchor" name="4bd28ac2a8594f875eca6bf64f2c352e"></a><!-- doxytag: member="MotionMatrix::quadratic_prod" ref="4bd28ac2a8594f875eca6bf64f2c352e" args="(const Eigen::Vector4d &amp;, const Eigen::Vector4d &amp;, typename Eigen::Matrix&lt; double, Eigen::Dynamic, 10 &gt;::RowXpr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMotionMatrix.html">MotionMatrix</a>&lt; V &gt;::quadratic_prod           </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector4d &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4d &amp;&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Eigen::Matrix&lt; double, Eigen::Dynamic, 10 &gt;::RowXpr&nbsp;</td>
          <td class="paramname"> <em>result</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets result to the elements of v*w^T 
</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="MotionMatrix_8h-source.html">MotionMatrix.h</a><li><a class="el" href="MotionMatrix_8hpp-source.html">MotionMatrix.hpp</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Jun 25 17:45:15 2012 for ProCamSolver by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
